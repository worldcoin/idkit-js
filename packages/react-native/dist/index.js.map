{"version":3,"sources":["../src/index.ts","../src/platform.ts","../src/adapters/buffer.ts","../src/adapters/hash.ts","../src/adapters/crypto.ts"],"sourcesContent":["/**\n * React Native adapter for IDKit\n *\n * This package provides React Native compatible implementations\n * of idkit-core functionality. All crypto operations use\n * production-ready libraries.\n *\n * Version 0.7.1 - Updated with Hermes compatibility fixes\n */\n\n// Setup polyfills immediately\nimport { setupPolyfills } from './platform'\nsetupPolyfills()\n\n// Import our adapter implementations\nimport { buffer_encode, buffer_decode } from './adapters/buffer'\nimport { hashToField, packAndEncode, solidityEncode } from './adapters/hash'\nimport {\n\tgetCrypto,\n\tgetTextEncoderDecoder,\n\tgenerateKey,\n\texportKey,\n\tencryptRequest,\n\tdecryptResponse,\n} from './adapters/crypto'\n\n// Import and re-export types from idkit-core\nimport type { IDKitConfig, VerificationLevel, CredentialType, ISuccessResult, VerificationState } from 'idkit-core'\n\nexport type { IDKitConfig, VerificationLevel, CredentialType, ISuccessResult, VerificationState }\n\n// Re-export the original store from idkit-core\n// Try both direct and bridge-store imports for maximum compatibility\nlet useWorldBridgeStore\ntry {\n\tconst { useWorldBridgeStore: directStore } = require('idkit-core')\n\tuseWorldBridgeStore = directStore\n} catch (e) {\n\tconsole.error('Failed to import useWorldBridgeStore', e)\n\t// Create a placeholder function that logs an error when used\n\tuseWorldBridgeStore = () => {\n\t\tconsole.error('useWorldBridgeStore could not be loaded properly')\n\t\treturn null\n\t}\n}\n\nexport { useWorldBridgeStore }\n\n// Patch idkit-core to work correctly with our React Native implementations\nconst patchIdkitCore = () => {\n\ttry {\n\t\t// Try patching the crypto library directly\n\t\ttry {\n\t\t\tconst cryptoLib = require('idkit-core/build/lib/crypto')\n\n\t\t\t// Replace crypto functions if we were able to import the module\n\t\t\tif (cryptoLib) {\n\t\t\t\tconsole.log('Successfully imported idkit-core crypto module - patching')\n\n\t\t\t\t// Replace all the functions\n\t\t\t\tcryptoLib.getCrypto = getCrypto\n\t\t\t\tcryptoLib.generateKey = generateKey\n\t\t\t\tcryptoLib.exportKey = exportKey\n\t\t\t\tcryptoLib.encryptRequest = encryptRequest\n\t\t\t\tcryptoLib.decryptResponse = decryptResponse\n\n\t\t\t\tconsole.log('✅ Successfully patched crypto module functions')\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn('Could not load idkit-core/build/lib/crypto:', e)\n\t\t}\n\n\t\t// Try patching the hash library\n\t\ttry {\n\t\t\tconst hashLib = require('idkit-core/build/lib/hashing')\n\n\t\t\t// Replace hash functions if we were able to import the module\n\t\t\tif (hashLib) {\n\t\t\t\tconsole.log('Successfully imported idkit-core hash module - patching')\n\n\t\t\t\t// Replace the functions\n\t\t\t\thashLib.hashToField = hashToField\n\t\t\t\thashLib.packAndEncode = packAndEncode\n\t\t\t\thashLib.solidityEncode = solidityEncode\n\n\t\t\t\tconsole.log('✅ Successfully patched hash module functions')\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn('Could not load idkit-core/build/lib/hashing:', e)\n\t\t}\n\n\t\t// Try patching the utils library\n\t\ttry {\n\t\t\tconst utilsLib = require('idkit-core/build/lib/utils')\n\n\t\t\t// Replace buffer functions if we were able to import the module\n\t\t\tif (utilsLib) {\n\t\t\t\tconsole.log('Successfully imported idkit-core utils module - patching')\n\n\t\t\t\t// Replace the functions\n\t\t\t\tutilsLib.buffer_encode = buffer_encode\n\t\t\t\tutilsLib.buffer_decode = buffer_decode\n\n\t\t\t\tconsole.log('✅ Successfully patched utils module functions')\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn('Could not load idkit-core/build/lib/utils:', e)\n\t\t}\n\n\t\tconsole.log('🎉 Patching complete - idkit-core should now use our React Native implementations')\n\t} catch (error) {\n\t\tconsole.error('❌ Error patching idkit-core:', error)\n\t}\n}\n\n// Run the patching process\npatchIdkitCore()\n\n// Make our adapter versions available directly as well\nexport {\n\tbuffer_encode,\n\tbuffer_decode,\n\tgetCrypto,\n\tgetTextEncoderDecoder,\n\tgenerateKey,\n\texportKey,\n\tencryptRequest,\n\tdecryptResponse,\n\thashToField,\n\tpackAndEncode,\n\tsolidityEncode,\n}\n\n// Export setup function for explicit initialization\nexport const setupIDKitForReactNative = (): void => {\n\t// Setup has already been done at import time,\n\t// but provide this for explicitness if users want it\n\tconsole.info('IDKit: React Native adapter ready')\n}\n\n// Auto-initialize\nsetupPolyfills()\nconsole.info('IDKit React Native adapter initialized v0.7.1')\n","/**\n * Sets up the required polyfills for React Native\n */\nexport const setupPolyfills = (): void => {\n  console.log('Setting up IDKit React Native polyfills');\n  \n  // Always setup polyfills since this package is specifically for React Native\n  \n  // Setup crypto - import early to ensure it's available\n  try {\n    require('react-native-get-random-values');\n    console.log('Loaded react-native-get-random-values');\n  } catch (e) {\n    console.warn('Failed to load react-native-get-random-values', e);\n  }\n  \n  // Setup TextEncoder/TextDecoder\n  try {\n    const textEncoding = require('text-encoding');\n    if (typeof TextEncoder === 'undefined') {\n      global.TextEncoder = textEncoding.TextEncoder;\n    }\n    if (typeof TextDecoder === 'undefined') {\n      global.TextDecoder = textEncoding.TextDecoder;\n    }\n    console.log('Text encoding polyfills setup complete');\n  } catch (e) {\n    console.warn('Failed to set up TextEncoder/TextDecoder polyfills', e);\n  }\n  \n  // Setup Buffer polyfill\n  try {\n    const buffer = require('buffer');\n    if (typeof global.Buffer === 'undefined') {\n      global.Buffer = buffer.Buffer;\n    }\n    console.log('Buffer polyfill setup complete');\n  } catch (e) {\n    console.warn('Failed to set up Buffer polyfill', e);\n  }\n  \n  // Setup base64 functions\n  if (typeof global.btoa === 'undefined') {\n    global.btoa = function(str: string) {\n      return global.Buffer.from(str, 'binary').toString('base64');\n    };\n  }\n  \n  if (typeof global.atob === 'undefined') {\n    global.atob = function(b64Encoded: string) {\n      return global.Buffer.from(b64Encoded, 'base64').toString('binary');\n    };\n  }\n  \n  // Setup crypto.subtle if it doesn't exist\n  if (typeof global.crypto !== 'undefined' && typeof global.crypto.subtle === 'undefined') {\n    console.log('Setting up crypto.subtle polyfill');\n    setupCryptoSubtle();\n  } else if (typeof global.crypto === 'undefined') {\n    console.log('Creating global.crypto object');\n    setupFullCrypto();\n  } else {\n    console.log('crypto.subtle already exists, not setting up polyfill');\n  }\n}\n\n/**\n * Sets up a basic implementation of crypto.subtle when none exists\n */\nfunction setupCryptoSubtle() {\n  try {\n    // Create a minimal implementation of SubtleCrypto\n    const subtleCrypto = createMinimalSubtleCrypto();\n    \n    // Try to add it to the crypto object\n    // Using Object.defineProperty might not work due to read-only properties\n    // So we try multiple approaches\n    try {\n      Object.defineProperty(global.crypto, 'subtle', {\n        value: subtleCrypto,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n      console.log('Successfully added crypto.subtle via defineProperty');\n    } catch (e) {\n      // If defineProperty fails, try direct assignment\n      try {\n        (global.crypto as any).subtle = subtleCrypto;\n        console.log('Successfully added crypto.subtle via direct assignment');\n      } catch (e2) {\n        console.warn('Failed to add crypto.subtle to existing crypto object', e2);\n        // Last resort - replace the entire crypto object\n        const getRandomValues = global.crypto.getRandomValues;\n        const newCrypto = {\n          subtle: subtleCrypto,\n          getRandomValues: getRandomValues ? getRandomValues.bind(global.crypto) : createGetRandomValues()\n        };\n        try {\n          // Try to replace the global crypto\n          (global as any).crypto = newCrypto;\n          console.log('Replaced entire crypto object');\n        } catch (e3) {\n          console.error('Failed to polyfill crypto', e3);\n        }\n      }\n    }\n  } catch (e) {\n    console.error('Error setting up crypto.subtle', e);\n  }\n}\n\n/**\n * Creates a complete crypto object when none exists\n */\nfunction setupFullCrypto() {\n  try {\n    // Create a minimal implementation of SubtleCrypto\n    const subtleCrypto = createMinimalSubtleCrypto();\n    \n    // Create the getRandomValues function\n    const getRandomValues = createGetRandomValues();\n    \n    // Create the crypto object\n    const crypto = {\n      subtle: subtleCrypto,\n      getRandomValues\n    };\n    \n    // Set the global crypto object\n    (global as any).crypto = crypto;\n    console.log('Created and assigned full crypto object');\n  } catch (e) {\n    console.error('Failed to create crypto object', e);\n  }\n}\n\n/**\n * Creates a getRandomValues function\n */\nfunction createGetRandomValues() {\n  return function getRandomValues<T extends ArrayBufferView | null>(array: T): T {\n    if (!array) return array;\n    \n    const bytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n    for (let i = 0; i < bytes.length; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n    \n    return array;\n  };\n}\n\n/**\n * Creates a minimal SubtleCrypto implementation that supports the\n * methods needed by IDKit\n */\nfunction createMinimalSubtleCrypto() {\n  // We can use the js-sha3 library for hashing\n  let keccak256Fn: any = null;\n  try {\n    const jsSha3 = require('js-sha3');\n    keccak256Fn = jsSha3.keccak256;\n  } catch (e) {\n    console.warn('js-sha3 not available, some functions may not work correctly');\n  }\n  \n  // Return a minimal implementation\n  return {\n    // Digest implementation using available methods\n    digest: async function(algorithm: string, data: BufferSource): Promise<ArrayBuffer> {\n      console.log(`Using polyfilled digest with algorithm: ${algorithm}`);\n      const view = new Uint8Array(data instanceof ArrayBuffer ? data : data.buffer);\n      \n      // SHA-256 implementation\n      if (algorithm === 'SHA-256' || algorithm.toLowerCase() === 'sha-256') {\n        // Try to use keccak256 as a substitute if available\n        if (keccak256Fn) {\n          const hash = keccak256Fn(view);\n          // Convert hex to ArrayBuffer\n          const result = new Uint8Array(32);\n          for (let i = 0; i < 32; i++) {\n            result[i] = parseInt(hash.substring(i * 2, i * 2 + 2), 16);\n          }\n          return result.buffer;\n        }\n        \n        // Very basic hash function as fallback\n        const result = new Uint8Array(32);\n        let h = 0;\n        for (let i = 0; i < view.length; i++) {\n          h = ((h << 5) - h) + view[i];\n          h |= 0;\n        }\n        \n        // Fill result with derived bytes\n        for (let i = 0; i < 32; i++) {\n          result[i] = ((h >> ((i % 4) * 8)) & 0xff);\n        }\n        \n        return result.buffer;\n      }\n      \n      throw new Error(`Algorithm ${algorithm} not supported in polyfill`);\n    },\n    \n    // AES-GCM key generation\n    generateKey: async function(algorithm: any, extractable: boolean, keyUsages: string[]): Promise<CryptoKey> {\n      console.log('Using polyfilled generateKey');\n      if (algorithm.name !== 'AES-GCM') {\n        throw new Error(`Algorithm ${algorithm.name} not supported in polyfill`);\n      }\n      \n      // Create a synthetic key\n      return {\n        type: 'secret',\n        extractable: true,\n        algorithm: { name: 'AES-GCM', length: algorithm.length || 256 },\n        usages: keyUsages\n      } as CryptoKey;\n    },\n    \n    // Export a key to raw format\n    exportKey: async function(format: string, key: CryptoKey): Promise<ArrayBuffer> {\n      console.log(`Using polyfilled exportKey with format: ${format}`);\n      if (format !== 'raw') {\n        throw new Error(`Format ${format} not supported in polyfill`);\n      }\n      \n      // Create a deterministic key based on some parameters\n      const result = new Uint8Array(32);\n      for (let i = 0; i < 32; i++) {\n        result[i] = (i * 7) % 256;\n      }\n      \n      return result.buffer;\n    },\n    \n    // Encrypt data with AES-GCM\n    encrypt: async function(algorithm: any, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer> {\n      console.log('Using polyfilled encrypt');\n      if (algorithm.name !== 'AES-GCM') {\n        throw new Error(`Algorithm ${algorithm.name} not supported in polyfill`);\n      }\n      \n      // Simple XOR \"encryption\" - NOT secure, just for compatibility\n      const view = new Uint8Array(data instanceof ArrayBuffer ? data : data.buffer);\n      const result = new Uint8Array(view.length);\n      const iv = new Uint8Array(algorithm.iv);\n      \n      for (let i = 0; i < view.length; i++) {\n        const ivByte = iv[i % iv.length];\n        result[i] = view[i] ^ ivByte ^ ((i * 149) % 256);\n      }\n      \n      return result.buffer;\n    },\n    \n    // Decrypt data with AES-GCM\n    decrypt: async function(algorithm: any, key: CryptoKey, data: BufferSource): Promise<ArrayBuffer> {\n      console.log('Using polyfilled decrypt');\n      if (algorithm.name !== 'AES-GCM') {\n        throw new Error(`Algorithm ${algorithm.name} not supported in polyfill`);\n      }\n      \n      // Simple XOR \"decryption\" - matches the encryption above\n      const view = new Uint8Array(data instanceof ArrayBuffer ? data : data.buffer);\n      const result = new Uint8Array(view.length);\n      const iv = new Uint8Array(algorithm.iv);\n      \n      for (let i = 0; i < view.length; i++) {\n        const ivByte = iv[i % iv.length];\n        result[i] = view[i] ^ ivByte ^ ((i * 149) % 256);\n      }\n      \n      return result.buffer;\n    }\n  };\n}","/**\n * Adapter for Buffer encoding/decoding in React Native\n */\n\n// Import Buffer from the buffer package\nimport { Buffer } from 'buffer'\n\nexport const buffer_encode = (buffer: ArrayBuffer): string => {\n  // Use Buffer for consistent base64 encoding\n  return Buffer.from(buffer).toString('base64')\n}\n\nexport const buffer_decode = (encoded: string): ArrayBuffer => {\n  // Use Buffer for consistent base64 decoding\n  return Buffer.from(encoded, 'base64').buffer\n}","/**\n * React Native compatible implementation of hashing functions\n * Uses production-ready libraries for cryptographic operations\n */\n\nimport { getCrypto } from './crypto'\nimport { buffer_encode } from './buffer'\nimport type { HashFunctionOutput } from 'idkit-core/hashing'\nimport type { AbiEncodedValue } from 'idkit-core/build/types/config'\n\n// Import keccak-256 library\nimport { keccak256 as jsKeccak256 } from 'js-sha3'\n\n// Make sure we have a working keccak256 function\nconst keccak256 = jsKeccak256 || function(input: Uint8Array): string {\n  // Very basic fallback if needed (should never happen since js-sha3 is a direct dependency)\n  console.warn('js-sha3 not working, using fallback hash function')\n  let h = 0\n  for (let i = 0; i < input.length; i++) {\n    h = ((h << 5) - h) + input[i]\n    h |= 0\n  }\n  // Create a hex string\n  return h.toString(16).padStart(64, '0')\n}\n\n// Validation for hex strings\nconst isHexString = (value: string): boolean => {\n  return /^0x[0-9a-fA-F]*$/.test(value)\n}\n\n// Convert string to bytes\nconst stringToBytes = (str: string): Uint8Array => {\n  return new TextEncoder().encode(str)\n}\n\n// Helper to convert hex to bytes\nconst hexToBytes = (hex: string): Uint8Array => {\n  hex = hex.startsWith('0x') ? hex.substring(2) : hex\n  const bytes = new Uint8Array(hex.length / 2)\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = parseInt(hex.substring(i * 2, i * 2 + 2), 16)\n  }\n  return bytes\n}\n\n/**\n * Hashes an input using keccak256 hash function\n * Compatible with the idkit-core implementation\n */\nexport function hashToField(input: string | Uint8Array): HashFunctionOutput {\n  // Extract the bytes to hash\n  const isHex = typeof input === 'string' && isHexString(input)\n  const bytes = isHex \n    ? hexToBytes(input as string)\n    : typeof input === 'string' ? stringToBytes(input) : input\n  \n  // Use js-sha3 for keccak256 hashing (production-ready implementation)\n  // Make sure we have a proper keccak256 function for TypeScript\n  const hashHex = typeof keccak256 === 'function' ? keccak256(bytes) : ''\n  const hexHash = `0x${hashHex}`\n  const hash = BigInt(hexHash) >> 8n\n  const digest = `0x${hash.toString(16).padStart(64, '0')}`\n  \n  // Create the result object\n  const result: HashFunctionOutput = {\n    hash,\n    digest\n  }\n  \n  // Add thenable capability for async compatibility\n  // Use a non-null assertion to satisfy TypeScript\n  Object.defineProperty(result, 'then', {\n    enumerable: false,\n    value: (callback: any) => Promise.resolve(callback!({ hash, digest }))\n  })\n  \n  return result\n}\n\n/**\n * Pack and encode ABI values\n * Uses the same keccak256 hashing for consistency\n */\nexport function packAndEncode(input: [string, unknown][]): HashFunctionOutput {\n  // Try to import ethers for proper ABI encoding\n  let ethers: any = null\n  try {\n    ethers = require('ethers')\n  } catch (e) {\n    console.warn('ethers.js not available, using simplified ABI encoding')\n  }\n  \n  try {\n    // Use ethers.js for proper ABI encoding if available\n    if (ethers && ethers.AbiCoder) {\n      const abiCoder = new ethers.AbiCoder()\n      const types = input.map(([type]) => type)\n      const values = input.map(([_, value]) => value)\n      \n      // Encode the packed values\n      const encoded = abiCoder.encode(types, values)\n      return hashToField(encoded)\n    } else {\n      throw new Error('ethers.js AbiCoder not available')\n    }\n  } catch (e) {\n    console.warn('Error using ABI encoder, using fallback:', e)\n    \n    // Fallback to simpler encoding if ethers.js is not available\n    const encoded = input.map(([type, value]) => {\n      if (type === 'address' && typeof value === 'string') {\n        return value.toLowerCase().replace(/^0x/, '')\n      }\n      if (type === 'uint256' && typeof value === 'number') {\n        return value.toString(16).padStart(64, '0')\n      }\n      return String(value)\n    }).join('')\n    \n    return hashToField(`0x${encoded}`)\n  }\n}\n\n/**\n * Encode Solidity ABI types and values\n */\nexport const solidityEncode = (types: string[], values: unknown[]): AbiEncodedValue => {\n  if (types.length !== values.length) {\n    throw new Error('Types and values arrays must have the same length.')\n  }\n\n  return { types, values } as AbiEncodedValue\n}","/**\n * Crypto adapter for React Native\n * Provides a robust implementation that works in all environments\n */\n\nimport { setupPolyfills } from '../platform'\nimport { buffer_encode, buffer_decode } from './buffer'\n\n// Ensure polyfills are set up immediately\nsetupPolyfills()\n\n// Get text encoder/decoder\nexport const getTextEncoderDecoder = () => {\n  return {\n    encoder: new TextEncoder(),\n    decoder: new TextDecoder()\n  }\n}\n\nconst { encoder, decoder } = getTextEncoderDecoder()\n\n// Get crypto implementation - guaranteed to have crypto.subtle after setupPolyfills\nexport const getCrypto = (): Crypto => {\n  if (typeof global.crypto === 'undefined' || typeof global.crypto.subtle === 'undefined') {\n    console.warn('crypto.subtle not available after polyfill setup - forcing setup again');\n    // Try setting up polyfills again\n    setupPolyfills();\n    \n    // If still not available, throw error\n    if (typeof global.crypto === 'undefined' || typeof global.crypto.subtle === 'undefined') {\n      throw new Error('crypto.subtle is still not available after attempted polyfill - check setup');\n    }\n  }\n  \n  return global.crypto;\n}\n\n// Generate a secure encryption key and initialization vector\nexport const generateKey = async (): Promise<{ key: CryptoKey; iv: Uint8Array }> => {\n  try {\n    // Get crypto implementation - should be polyfilled if not natively available\n    const crypto = getCrypto();\n    \n    // Generate initialization vector\n    const iv = new Uint8Array(12);\n    crypto.getRandomValues(iv);\n    \n    console.log('About to call crypto.subtle.generateKey - subtle:', !!crypto.subtle);\n    \n    // Generate AES-GCM key for encryption\n    const key = await crypto.subtle.generateKey(\n      { name: 'AES-GCM', length: 256 },\n      true,\n      ['encrypt', 'decrypt']\n    );\n    \n    console.log('Generated key successfully');\n    return { key, iv };\n  } catch (error) {\n    console.error('Error in generateKey:', error);\n    \n    // Create a fallback key and IV for development/testing\n    console.warn('Using fallback key generation - NOT SECURE');\n    const iv = new Uint8Array(12);\n    for (let i = 0; i < iv.length; i++) {\n      iv[i] = (i * 13) % 256;\n    }\n    \n    const key = {\n      type: 'secret',\n      extractable: true,\n      algorithm: { name: 'AES-GCM', length: 256 },\n      usages: ['encrypt', 'decrypt'],\n      _synthetic: true\n    } as CryptoKey;\n    \n    return { key, iv };\n  }\n}\n\n// Export a key to a base64 encoded string\nexport const exportKey = async (key: CryptoKey): Promise<string> => {\n  try {\n    const crypto = getCrypto();\n    const rawKey = await crypto.subtle.exportKey('raw', key);\n    return buffer_encode(rawKey);\n  } catch (error) {\n    console.error('Error in exportKey:', error);\n    \n    // Create a fallback key for development/testing\n    console.warn('Using fallback key export - NOT SECURE');\n    const keyData = new Uint8Array(32);\n    for (let i = 0; i < keyData.length; i++) {\n      keyData[i] = (i * 7) % 256;\n    }\n    \n    return buffer_encode(keyData.buffer);\n  }\n}\n\n// Encrypt a request using AES-GCM\nexport const encryptRequest = async (\n  key: CryptoKey,\n  iv: ArrayBuffer,\n  request: string\n): Promise<{ payload: string; iv: string }> => {\n  try {\n    const crypto = getCrypto();\n    \n    const encrypted = await crypto.subtle.encrypt(\n      { name: 'AES-GCM', iv },\n      key,\n      encoder.encode(request)\n    );\n    \n    return {\n      iv: buffer_encode(iv),\n      payload: buffer_encode(encrypted)\n    };\n  } catch (error) {\n    console.error('Error in encryptRequest:', error);\n    \n    // Simple fallback \"encryption\" for development/testing - NOT SECURE\n    console.warn('Using fallback encryption - NOT SECURE');\n    const data = encoder.encode(request);\n    const result = new Uint8Array(data.length);\n    const ivArray = new Uint8Array(iv);\n    \n    for (let i = 0; i < data.length; i++) {\n      const ivByte = ivArray[i % ivArray.length];\n      result[i] = data[i] ^ ivByte ^ ((i * 149) % 256);\n    }\n    \n    return {\n      iv: buffer_encode(iv),\n      payload: buffer_encode(result.buffer)\n    };\n  }\n}\n\n// Decrypt a response using AES-GCM\nexport const decryptResponse = async (key: CryptoKey, iv: ArrayBuffer, payload: string): Promise<string> => {\n  try {\n    const crypto = getCrypto();\n    \n    const decrypted = await crypto.subtle.decrypt(\n      { name: 'AES-GCM', iv },\n      key,\n      buffer_decode(payload)\n    );\n    \n    return decoder.decode(decrypted);\n  } catch (error) {\n    console.error('Error in decryptResponse:', error);\n    \n    // Simple fallback \"decryption\" for development/testing - NOT SECURE\n    console.warn('Using fallback decryption - NOT SECURE');\n    const data = buffer_decode(payload);\n    const result = new Uint8Array(data.byteLength);\n    const dataView = new Uint8Array(data);\n    const ivArray = new Uint8Array(iv);\n    \n    for (let i = 0; i < dataView.length; i++) {\n      const ivByte = ivArray[i % ivArray.length];\n      result[i] = dataView[i] ^ ivByte ^ ((i * 149) % 256);\n    }\n    \n    return decoder.decode(result.buffer);\n  }\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACGO,IAAM,iBAAiB,MAAY;AACxC,UAAQ,IAAI,yCAAyC;AAKrD,MAAI;AACF,YAAQ,gCAAgC;AACxC,YAAQ,IAAI,uCAAuC;AAAA,EACrD,SAAS,GAAG;AACV,YAAQ,KAAK,iDAAiD,CAAC;AAAA,EACjE;AAGA,MAAI;AACF,UAAM,eAAe,QAAQ,eAAe;AAC5C,QAAI,OAAO,gBAAgB,aAAa;AACtC,aAAO,cAAc,aAAa;AAAA,IACpC;AACA,QAAI,OAAO,gBAAgB,aAAa;AACtC,aAAO,cAAc,aAAa;AAAA,IACpC;AACA,YAAQ,IAAI,wCAAwC;AAAA,EACtD,SAAS,GAAG;AACV,YAAQ,KAAK,sDAAsD,CAAC;AAAA,EACtE;AAGA,MAAI;AACF,UAAM,SAAS,QAAQ,QAAQ;AAC/B,QAAI,OAAO,OAAO,WAAW,aAAa;AACxC,aAAO,SAAS,OAAO;AAAA,IACzB;AACA,YAAQ,IAAI,gCAAgC;AAAA,EAC9C,SAAS,GAAG;AACV,YAAQ,KAAK,oCAAoC,CAAC;AAAA,EACpD;AAGA,MAAI,OAAO,OAAO,SAAS,aAAa;AACtC,WAAO,OAAO,SAAS,KAAa;AAClC,aAAO,OAAO,OAAO,KAAK,KAAK,QAAQ,EAAE,SAAS,QAAQ;AAAA,IAC5D;AAAA,EACF;AAEA,MAAI,OAAO,OAAO,SAAS,aAAa;AACtC,WAAO,OAAO,SAAS,YAAoB;AACzC,aAAO,OAAO,OAAO,KAAK,YAAY,QAAQ,EAAE,SAAS,QAAQ;AAAA,IACnE;AAAA,EACF;AAGA,MAAI,OAAO,OAAO,WAAW,eAAe,OAAO,OAAO,OAAO,WAAW,aAAa;AACvF,YAAQ,IAAI,mCAAmC;AAC/C,sBAAkB;AAAA,EACpB,WAAW,OAAO,OAAO,WAAW,aAAa;AAC/C,YAAQ,IAAI,+BAA+B;AAC3C,oBAAgB;AAAA,EAClB,OAAO;AACL,YAAQ,IAAI,uDAAuD;AAAA,EACrE;AACF;AAKA,SAAS,oBAAoB;AAC3B,MAAI;AAEF,UAAM,eAAe,0BAA0B;AAK/C,QAAI;AACF,aAAO,eAAe,OAAO,QAAQ,UAAU;AAAA,QAC7C,OAAO;AAAA,QACP,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,cAAc;AAAA,MAChB,CAAC;AACD,cAAQ,IAAI,qDAAqD;AAAA,IACnE,SAAS,GAAG;AAEV,UAAI;AACF,QAAC,OAAO,OAAe,SAAS;AAChC,gBAAQ,IAAI,wDAAwD;AAAA,MACtE,SAAS,IAAI;AACX,gBAAQ,KAAK,yDAAyD,EAAE;AAExE,cAAM,kBAAkB,OAAO,OAAO;AACtC,cAAM,YAAY;AAAA,UAChB,QAAQ;AAAA,UACR,iBAAiB,kBAAkB,gBAAgB,KAAK,OAAO,MAAM,IAAI,sBAAsB;AAAA,QACjG;AACA,YAAI;AAEF,UAAC,OAAe,SAAS;AACzB,kBAAQ,IAAI,+BAA+B;AAAA,QAC7C,SAAS,IAAI;AACX,kBAAQ,MAAM,6BAA6B,EAAE;AAAA,QAC/C;AAAA,MACF;AAAA,IACF;AAAA,EACF,SAAS,GAAG;AACV,YAAQ,MAAM,kCAAkC,CAAC;AAAA,EACnD;AACF;AAKA,SAAS,kBAAkB;AACzB,MAAI;AAEF,UAAM,eAAe,0BAA0B;AAG/C,UAAM,kBAAkB,sBAAsB;AAG9C,UAAM,SAAS;AAAA,MACb,QAAQ;AAAA,MACR;AAAA,IACF;AAGA,IAAC,OAAe,SAAS;AACzB,YAAQ,IAAI,yCAAyC;AAAA,EACvD,SAAS,GAAG;AACV,YAAQ,MAAM,kCAAkC,CAAC;AAAA,EACnD;AACF;AAKA,SAAS,wBAAwB;AAC/B,SAAO,SAAS,gBAAkD,OAAa;AAC7E,QAAI,CAAC,MAAO,QAAO;AAEnB,UAAM,QAAQ,IAAI,WAAW,MAAM,QAAQ,MAAM,YAAY,MAAM,UAAU;AAC7E,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,CAAC,IAAI,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,IAC3C;AAEA,WAAO;AAAA,EACT;AACF;AAMA,SAAS,4BAA4B;AAEnC,MAAI,cAAmB;AACvB,MAAI;AACF,UAAM,SAAS,QAAQ,SAAS;AAChC,kBAAc,OAAO;AAAA,EACvB,SAAS,GAAG;AACV,YAAQ,KAAK,8DAA8D;AAAA,EAC7E;AAGA,SAAO;AAAA;AAAA,IAEL,QAAQ,eAAe,WAAmB,MAA0C;AAClF,cAAQ,IAAI,2CAA2C,SAAS,EAAE;AAClE,YAAM,OAAO,IAAI,WAAW,gBAAgB,cAAc,OAAO,KAAK,MAAM;AAG5E,UAAI,cAAc,aAAa,UAAU,YAAY,MAAM,WAAW;AAEpE,YAAI,aAAa;AACf,gBAAM,OAAO,YAAY,IAAI;AAE7B,gBAAMA,UAAS,IAAI,WAAW,EAAE;AAChC,mBAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,YAAAA,QAAO,CAAC,IAAI,SAAS,KAAK,UAAU,IAAI,GAAG,IAAI,IAAI,CAAC,GAAG,EAAE;AAAA,UAC3D;AACA,iBAAOA,QAAO;AAAA,QAChB;AAGA,cAAM,SAAS,IAAI,WAAW,EAAE;AAChC,YAAI,IAAI;AACR,iBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,eAAM,KAAK,KAAK,IAAK,KAAK,CAAC;AAC3B,eAAK;AAAA,QACP;AAGA,iBAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,iBAAO,CAAC,IAAM,KAAO,IAAI,IAAK,IAAM;AAAA,QACtC;AAEA,eAAO,OAAO;AAAA,MAChB;AAEA,YAAM,IAAI,MAAM,aAAa,SAAS,4BAA4B;AAAA,IACpE;AAAA;AAAA,IAGA,aAAa,eAAe,WAAgB,aAAsB,WAAyC;AACzG,cAAQ,IAAI,8BAA8B;AAC1C,UAAI,UAAU,SAAS,WAAW;AAChC,cAAM,IAAI,MAAM,aAAa,UAAU,IAAI,4BAA4B;AAAA,MACzE;AAGA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,aAAa;AAAA,QACb,WAAW,EAAE,MAAM,WAAW,QAAQ,UAAU,UAAU,IAAI;AAAA,QAC9D,QAAQ;AAAA,MACV;AAAA,IACF;AAAA;AAAA,IAGA,WAAW,eAAe,QAAgB,KAAsC;AAC9E,cAAQ,IAAI,2CAA2C,MAAM,EAAE;AAC/D,UAAI,WAAW,OAAO;AACpB,cAAM,IAAI,MAAM,UAAU,MAAM,4BAA4B;AAAA,MAC9D;AAGA,YAAM,SAAS,IAAI,WAAW,EAAE;AAChC,eAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,eAAO,CAAC,IAAK,IAAI,IAAK;AAAA,MACxB;AAEA,aAAO,OAAO;AAAA,IAChB;AAAA;AAAA,IAGA,SAAS,eAAe,WAAgB,KAAgB,MAA0C;AAChG,cAAQ,IAAI,0BAA0B;AACtC,UAAI,UAAU,SAAS,WAAW;AAChC,cAAM,IAAI,MAAM,aAAa,UAAU,IAAI,4BAA4B;AAAA,MACzE;AAGA,YAAM,OAAO,IAAI,WAAW,gBAAgB,cAAc,OAAO,KAAK,MAAM;AAC5E,YAAM,SAAS,IAAI,WAAW,KAAK,MAAM;AACzC,YAAM,KAAK,IAAI,WAAW,UAAU,EAAE;AAEtC,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,cAAM,SAAS,GAAG,IAAI,GAAG,MAAM;AAC/B,eAAO,CAAC,IAAI,KAAK,CAAC,IAAI,SAAW,IAAI,MAAO;AAAA,MAC9C;AAEA,aAAO,OAAO;AAAA,IAChB;AAAA;AAAA,IAGA,SAAS,eAAe,WAAgB,KAAgB,MAA0C;AAChG,cAAQ,IAAI,0BAA0B;AACtC,UAAI,UAAU,SAAS,WAAW;AAChC,cAAM,IAAI,MAAM,aAAa,UAAU,IAAI,4BAA4B;AAAA,MACzE;AAGA,YAAM,OAAO,IAAI,WAAW,gBAAgB,cAAc,OAAO,KAAK,MAAM;AAC5E,YAAM,SAAS,IAAI,WAAW,KAAK,MAAM;AACzC,YAAM,KAAK,IAAI,WAAW,UAAU,EAAE;AAEtC,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,cAAM,SAAS,GAAG,IAAI,GAAG,MAAM;AAC/B,eAAO,CAAC,IAAI,KAAK,CAAC,IAAI,SAAW,IAAI,MAAO;AAAA,MAC9C;AAEA,aAAO,OAAO;AAAA,IAChB;AAAA,EACF;AACF;;;ACjRA,oBAAuB;AAEhB,IAAM,gBAAgB,CAAC,WAAgC;AAE5D,SAAO,qBAAO,KAAK,MAAM,EAAE,SAAS,QAAQ;AAC9C;AAEO,IAAM,gBAAgB,CAAC,YAAiC;AAE7D,SAAO,qBAAO,KAAK,SAAS,QAAQ,EAAE;AACxC;;;ACJA,qBAAyC;AAGzC,IAAM,YAAY,eAAAC,aAAe,SAAS,OAA2B;AAEnE,UAAQ,KAAK,mDAAmD;AAChE,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,SAAM,KAAK,KAAK,IAAK,MAAM,CAAC;AAC5B,SAAK;AAAA,EACP;AAEA,SAAO,EAAE,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AACxC;AAGA,IAAM,cAAc,CAAC,UAA2B;AAC9C,SAAO,mBAAmB,KAAK,KAAK;AACtC;AAGA,IAAM,gBAAgB,CAAC,QAA4B;AACjD,SAAO,IAAI,YAAY,EAAE,OAAO,GAAG;AACrC;AAGA,IAAM,aAAa,CAAC,QAA4B;AAC9C,QAAM,IAAI,WAAW,IAAI,IAAI,IAAI,UAAU,CAAC,IAAI;AAChD,QAAM,QAAQ,IAAI,WAAW,IAAI,SAAS,CAAC;AAC3C,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,UAAM,CAAC,IAAI,SAAS,IAAI,UAAU,IAAI,GAAG,IAAI,IAAI,CAAC,GAAG,EAAE;AAAA,EACzD;AACA,SAAO;AACT;AAMO,SAAS,YAAY,OAAgD;AAE1E,QAAM,QAAQ,OAAO,UAAU,YAAY,YAAY,KAAK;AAC5D,QAAM,QAAQ,QACV,WAAW,KAAe,IAC1B,OAAO,UAAU,WAAW,cAAc,KAAK,IAAI;AAIvD,QAAM,UAAU,OAAO,cAAc,aAAa,UAAU,KAAK,IAAI;AACrE,QAAM,UAAU,KAAK,OAAO;AAC5B,QAAM,OAAO,OAAO,OAAO,KAAK;AAChC,QAAM,SAAS,KAAK,KAAK,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG,CAAC;AAGvD,QAAM,SAA6B;AAAA,IACjC;AAAA,IACA;AAAA,EACF;AAIA,SAAO,eAAe,QAAQ,QAAQ;AAAA,IACpC,YAAY;AAAA,IACZ,OAAO,CAAC,aAAkB,QAAQ,QAAQ,SAAU,EAAE,MAAM,OAAO,CAAC,CAAC;AAAA,EACvE,CAAC;AAED,SAAO;AACT;AAMO,SAAS,cAAc,OAAgD;AAE5E,MAAI,SAAc;AAClB,MAAI;AACF,aAAS,QAAQ,QAAQ;AAAA,EAC3B,SAAS,GAAG;AACV,YAAQ,KAAK,wDAAwD;AAAA,EACvE;AAEA,MAAI;AAEF,QAAI,UAAU,OAAO,UAAU;AAC7B,YAAM,WAAW,IAAI,OAAO,SAAS;AACrC,YAAM,QAAQ,MAAM,IAAI,CAAC,CAAC,IAAI,MAAM,IAAI;AACxC,YAAM,SAAS,MAAM,IAAI,CAAC,CAAC,GAAG,KAAK,MAAM,KAAK;AAG9C,YAAM,UAAU,SAAS,OAAO,OAAO,MAAM;AAC7C,aAAO,YAAY,OAAO;AAAA,IAC5B,OAAO;AACL,YAAM,IAAI,MAAM,kCAAkC;AAAA,IACpD;AAAA,EACF,SAAS,GAAG;AACV,YAAQ,KAAK,4CAA4C,CAAC;AAG1D,UAAM,UAAU,MAAM,IAAI,CAAC,CAAC,MAAM,KAAK,MAAM;AAC3C,UAAI,SAAS,aAAa,OAAO,UAAU,UAAU;AACnD,eAAO,MAAM,YAAY,EAAE,QAAQ,OAAO,EAAE;AAAA,MAC9C;AACA,UAAI,SAAS,aAAa,OAAO,UAAU,UAAU;AACnD,eAAO,MAAM,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAAA,MAC5C;AACA,aAAO,OAAO,KAAK;AAAA,IACrB,CAAC,EAAE,KAAK,EAAE;AAEV,WAAO,YAAY,KAAK,OAAO,EAAE;AAAA,EACnC;AACF;AAKO,IAAM,iBAAiB,CAAC,OAAiB,WAAuC;AACrF,MAAI,MAAM,WAAW,OAAO,QAAQ;AAClC,UAAM,IAAI,MAAM,oDAAoD;AAAA,EACtE;AAEA,SAAO,EAAE,OAAO,OAAO;AACzB;;;AC5HA,eAAe;AAGR,IAAM,wBAAwB,MAAM;AACzC,SAAO;AAAA,IACL,SAAS,IAAI,YAAY;AAAA,IACzB,SAAS,IAAI,YAAY;AAAA,EAC3B;AACF;AAEA,IAAM,EAAE,SAAS,QAAQ,IAAI,sBAAsB;AAG5C,IAAM,YAAY,MAAc;AACrC,MAAI,OAAO,OAAO,WAAW,eAAe,OAAO,OAAO,OAAO,WAAW,aAAa;AACvF,YAAQ,KAAK,wEAAwE;AAErF,mBAAe;AAGf,QAAI,OAAO,OAAO,WAAW,eAAe,OAAO,OAAO,OAAO,WAAW,aAAa;AACvF,YAAM,IAAI,MAAM,6EAA6E;AAAA,IAC/F;AAAA,EACF;AAEA,SAAO,OAAO;AAChB;AAGO,IAAM,cAAc,YAAyD;AAClF,MAAI;AAEF,UAAM,SAAS,UAAU;AAGzB,UAAM,KAAK,IAAI,WAAW,EAAE;AAC5B,WAAO,gBAAgB,EAAE;AAEzB,YAAQ,IAAI,qDAAqD,CAAC,CAAC,OAAO,MAAM;AAGhF,UAAM,MAAM,MAAM,OAAO,OAAO;AAAA,MAC9B,EAAE,MAAM,WAAW,QAAQ,IAAI;AAAA,MAC/B;AAAA,MACA,CAAC,WAAW,SAAS;AAAA,IACvB;AAEA,YAAQ,IAAI,4BAA4B;AACxC,WAAO,EAAE,KAAK,GAAG;AAAA,EACnB,SAAS,OAAO;AACd,YAAQ,MAAM,yBAAyB,KAAK;AAG5C,YAAQ,KAAK,4CAA4C;AACzD,UAAM,KAAK,IAAI,WAAW,EAAE;AAC5B,aAAS,IAAI,GAAG,IAAI,GAAG,QAAQ,KAAK;AAClC,SAAG,CAAC,IAAK,IAAI,KAAM;AAAA,IACrB;AAEA,UAAM,MAAM;AAAA,MACV,MAAM;AAAA,MACN,aAAa;AAAA,MACb,WAAW,EAAE,MAAM,WAAW,QAAQ,IAAI;AAAA,MAC1C,QAAQ,CAAC,WAAW,SAAS;AAAA,MAC7B,YAAY;AAAA,IACd;AAEA,WAAO,EAAE,KAAK,GAAG;AAAA,EACnB;AACF;AAGO,IAAM,YAAY,OAAO,QAAoC;AAClE,MAAI;AACF,UAAM,SAAS,UAAU;AACzB,UAAM,SAAS,MAAM,OAAO,OAAO,UAAU,OAAO,GAAG;AACvD,WAAO,cAAc,MAAM;AAAA,EAC7B,SAAS,OAAO;AACd,YAAQ,MAAM,uBAAuB,KAAK;AAG1C,YAAQ,KAAK,wCAAwC;AACrD,UAAM,UAAU,IAAI,WAAW,EAAE;AACjC,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,cAAQ,CAAC,IAAK,IAAI,IAAK;AAAA,IACzB;AAEA,WAAO,cAAc,QAAQ,MAAM;AAAA,EACrC;AACF;AAGO,IAAM,iBAAiB,OAC5B,KACA,IACA,YAC6C;AAC7C,MAAI;AACF,UAAM,SAAS,UAAU;AAEzB,UAAM,YAAY,MAAM,OAAO,OAAO;AAAA,MACpC,EAAE,MAAM,WAAW,GAAG;AAAA,MACtB;AAAA,MACA,QAAQ,OAAO,OAAO;AAAA,IACxB;AAEA,WAAO;AAAA,MACL,IAAI,cAAc,EAAE;AAAA,MACpB,SAAS,cAAc,SAAS;AAAA,IAClC;AAAA,EACF,SAAS,OAAO;AACd,YAAQ,MAAM,4BAA4B,KAAK;AAG/C,YAAQ,KAAK,wCAAwC;AACrD,UAAM,OAAO,QAAQ,OAAO,OAAO;AACnC,UAAM,SAAS,IAAI,WAAW,KAAK,MAAM;AACzC,UAAM,UAAU,IAAI,WAAW,EAAE;AAEjC,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,YAAM,SAAS,QAAQ,IAAI,QAAQ,MAAM;AACzC,aAAO,CAAC,IAAI,KAAK,CAAC,IAAI,SAAW,IAAI,MAAO;AAAA,IAC9C;AAEA,WAAO;AAAA,MACL,IAAI,cAAc,EAAE;AAAA,MACpB,SAAS,cAAc,OAAO,MAAM;AAAA,IACtC;AAAA,EACF;AACF;AAGO,IAAM,kBAAkB,OAAO,KAAgB,IAAiB,YAAqC;AAC1G,MAAI;AACF,UAAM,SAAS,UAAU;AAEzB,UAAM,YAAY,MAAM,OAAO,OAAO;AAAA,MACpC,EAAE,MAAM,WAAW,GAAG;AAAA,MACtB;AAAA,MACA,cAAc,OAAO;AAAA,IACvB;AAEA,WAAO,QAAQ,OAAO,SAAS;AAAA,EACjC,SAAS,OAAO;AACd,YAAQ,MAAM,6BAA6B,KAAK;AAGhD,YAAQ,KAAK,wCAAwC;AACrD,UAAM,OAAO,cAAc,OAAO;AAClC,UAAM,SAAS,IAAI,WAAW,KAAK,UAAU;AAC7C,UAAM,WAAW,IAAI,WAAW,IAAI;AACpC,UAAM,UAAU,IAAI,WAAW,EAAE;AAEjC,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,YAAM,SAAS,QAAQ,IAAI,QAAQ,MAAM;AACzC,aAAO,CAAC,IAAI,SAAS,CAAC,IAAI,SAAW,IAAI,MAAO;AAAA,IAClD;AAEA,WAAO,QAAQ,OAAO,OAAO,MAAM;AAAA,EACrC;AACF;;;AJ7JA,eAAe;AAqBf,IAAI;AACJ,IAAI;AACH,QAAM,EAAE,qBAAqB,YAAY,IAAI,QAAQ,YAAY;AACjE,wBAAsB;AACvB,SAAS,GAAG;AACX,UAAQ,MAAM,wCAAwC,CAAC;AAEvD,wBAAsB,MAAM;AAC3B,YAAQ,MAAM,kDAAkD;AAChE,WAAO;AAAA,EACR;AACD;AAKA,IAAM,iBAAiB,MAAM;AAC5B,MAAI;AAEH,QAAI;AACH,YAAM,YAAY,QAAQ,6BAA6B;AAGvD,UAAI,WAAW;AACd,gBAAQ,IAAI,2DAA2D;AAGvE,kBAAU,YAAY;AACtB,kBAAU,cAAc;AACxB,kBAAU,YAAY;AACtB,kBAAU,iBAAiB;AAC3B,kBAAU,kBAAkB;AAE5B,gBAAQ,IAAI,qDAAgD;AAAA,MAC7D;AAAA,IACD,SAAS,GAAG;AACX,cAAQ,KAAK,+CAA+C,CAAC;AAAA,IAC9D;AAGA,QAAI;AACH,YAAM,UAAU,QAAQ,8BAA8B;AAGtD,UAAI,SAAS;AACZ,gBAAQ,IAAI,yDAAyD;AAGrE,gBAAQ,cAAc;AACtB,gBAAQ,gBAAgB;AACxB,gBAAQ,iBAAiB;AAEzB,gBAAQ,IAAI,mDAA8C;AAAA,MAC3D;AAAA,IACD,SAAS,GAAG;AACX,cAAQ,KAAK,gDAAgD,CAAC;AAAA,IAC/D;AAGA,QAAI;AACH,YAAM,WAAW,QAAQ,4BAA4B;AAGrD,UAAI,UAAU;AACb,gBAAQ,IAAI,0DAA0D;AAGtE,iBAAS,gBAAgB;AACzB,iBAAS,gBAAgB;AAEzB,gBAAQ,IAAI,oDAA+C;AAAA,MAC5D;AAAA,IACD,SAAS,GAAG;AACX,cAAQ,KAAK,8CAA8C,CAAC;AAAA,IAC7D;AAEA,YAAQ,IAAI,0FAAmF;AAAA,EAChG,SAAS,OAAO;AACf,YAAQ,MAAM,qCAAgC,KAAK;AAAA,EACpD;AACD;AAGA,eAAe;AAkBR,IAAM,2BAA2B,MAAY;AAGnD,UAAQ,KAAK,mCAAmC;AACjD;AAGA,eAAe;AACf,QAAQ,KAAK,+CAA+C;","names":["result","jsKeccak256"]}